# -*- coding: utf-8 -*-
"""cyclical_encoding.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uG2hCKUCFCsGXYJc-jD1pEm6MW-9c2_9
"""

import pandas as pd
import numpy as np
from sklearn.preprocessing import MinMaxScaler

# Load the data
data = pd.read_csv("all_features2.csv")
# Specify the columns you want to keep, including the new calendar variables
columns_to_keep = ['datetime', 'Load',
                  'Load_previous_hour',	'Load_same_hour_previous_day',	'Load_same_hour_previous_week',
                'day_of_year', 'hour'	 ,  'day_part_encoded' ]

# Use indexing to select the desired columns
df = data[columns_to_keep]
df['datetime'] = pd.to_datetime(df['datetime'] , utc=True)

df.set_index('datetime', inplace=True)
df.head()

# Ciclical encoding
# ==============================================================================
def cyclical_encoding(data: pd.Series, cycle_length: int) -> pd.DataFrame:
    """
    Encode a cyclical feature with two new features sine and cosine.
    The minimum value of the feature is assumed to be 0. The maximum value
    of the feature is passed as an argument.

    Parameters
    ----------
    data : pd.Series
        Series with the feature to encode.
    cycle_length : int
        The length of the cycle. For example, 12 for months, 24 for hours, etc.
        This value is used to calculate the angle of the sin and cos.

    Returns
    -------
    pd.DataFrame
        Dataframe with the two new features sin and cos.

    """

    sin = np.sin(2 * np.pi * data/cycle_length)
    cos = np.cos(2 * np.pi * data/cycle_length)
    result =  pd.DataFrame({
                  f"{data.name}_sin": sin,
                  f"{data.name}_cos": cos
              })

    return result

calendar_features= df



# Ciclical encoding of month, day of week and hour
# ==============================================================================
#month_encoded = cyclical_encoding(calendar_features['month'], cycle_length=12)
#day_of_week_encoded = cyclical_encoding(calendar_features['day_of_week'], cycle_length=7)
hour_encoded = cyclical_encoding(calendar_features['hour'], cycle_length=24)
day_of_year_encoded = cyclical_encoding(calendar_features['day_of_year'], cycle_length=365)

#day_of_month_encoded = cyclical_encoding(calendar_features['day_of_month'], cycle_length=30)


cyclical_features = pd.concat([ hour_encoded, day_of_year_encoded], axis=1)
cyclical_features.head()

import matplotlib.pyplot as plt
import seaborn as sns

# Plot value of sin and cos for each hour
# ==============================================================================
fig, ax = plt.subplots(figsize=(3.5, 3))
sp = ax.scatter(
         day_of_year_encoded["day_of_year_sin"],
         day_of_year_encoded["day_of_year_cos"],
         c    = calendar_features['hour'],
         cmap = 'viridis'
     )
ax.set(
    xlabel="sin(day_of_year_encoded)",
    ylabel="cos(day_of_year_encoded)",
)
_ = fig.colorbar(sp)
plt.show();

newdf2 = df.merge(cyclical_features, on='datetime')
newdf2=newdf2.drop(columns=['hour', 'day_of_year'])
newdf2.head()

newdf2.info()

# Reset the index
newdf2_reset = newdf2.reset_index()

# Save data to CSV
newdf2_reset.to_csv('all(opt).csv', index=False)

newdf2_reset